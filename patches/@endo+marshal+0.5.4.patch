diff --git a/node_modules/@endo/marshal/exported.js b/node_modules/@endo/marshal/exported.js
index f4cba01..7036eb8 100644
--- a/node_modules/@endo/marshal/exported.js
+++ b/node_modules/@endo/marshal/exported.js
@@ -1 +1,2 @@
-import './src/types.js';
+// eslint-disable-next-line import/export
+export * from './src/types.js';
diff --git a/node_modules/@endo/marshal/index.d.ts b/node_modules/@endo/marshal/index.d.ts
new file mode 100644
index 0000000..cd80073
--- /dev/null
+++ b/node_modules/@endo/marshal/index.d.ts
@@ -0,0 +1,14 @@
+export { deeplyFulfilled } from "./src/deeplyFulfilled.js";
+export { makeTagged } from "./src/makeTagged.js";
+export { mapIterable, filterIterable } from "./src/helpers/iter-helpers.js";
+export { PASS_STYLE, isObject, assertChecker, getTag, hasOwnPropertyOf } from "./src/helpers/passStyle-helpers.js";
+export { getErrorConstructor, toPassableError } from "./src/helpers/error.js";
+export { getInterfaceOf, ALLOW_IMPLICIT_REMOTABLES } from "./src/helpers/remotable.js";
+export { nameForPassableSymbol, passableSymbolForName } from "./src/helpers/symbol.js";
+export { passStyleOf, assertPassable } from "./src/passStyleOf.js";
+export { pureCopy, sameValueZero } from "./src/pureCopy.js";
+export { Remotable, Far, ToFarFunction } from "./src/make-far.js";
+export { QCLASS, makeMarshal } from "./src/marshal.js";
+export { stringify, parse } from "./src/marshal-stringify.js";
+export { assertRecord, assertCopyArray, assertRemotable, isRemotable, isRecord, isCopyArray } from "./src/typeGuards.js";
+//# sourceMappingURL=index.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@endo/marshal/index.d.ts.map b/node_modules/@endo/marshal/index.d.ts.map
new file mode 100644
index 0000000..ca7a93a
--- /dev/null
+++ b/node_modules/@endo/marshal/index.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["index.js"],"names":[],"mappings":""}
\ No newline at end of file
diff --git a/node_modules/@endo/marshal/src/deeplyFulfilled.d.ts b/node_modules/@endo/marshal/src/deeplyFulfilled.d.ts
new file mode 100644
index 0000000..f83c2b6
--- /dev/null
+++ b/node_modules/@endo/marshal/src/deeplyFulfilled.d.ts
@@ -0,0 +1,4 @@
+export function deeplyFulfilled(val: Passable): ERef<Passable>;
+export type Passable = any;
+export type ERef<T> = T | PromiseLike<T>;
+//# sourceMappingURL=deeplyFulfilled.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@endo/marshal/src/deeplyFulfilled.d.ts.map b/node_modules/@endo/marshal/src/deeplyFulfilled.d.ts.map
new file mode 100644
index 0000000..6d1a40e
--- /dev/null
+++ b/node_modules/@endo/marshal/src/deeplyFulfilled.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"deeplyFulfilled.d.ts","sourceRoot":"","sources":["deeplyFulfilled.js"],"names":[],"mappings":"AAsCO,qCAHI,QAAQ,GACN,KAAK,QAAQ,CAAC,CAyC1B"}
\ No newline at end of file
diff --git a/node_modules/@endo/marshal/src/deeplyFulfilled.js b/node_modules/@endo/marshal/src/deeplyFulfilled.js
index 3084cf3..dc2104e 100644
--- a/node_modules/@endo/marshal/src/deeplyFulfilled.js
+++ b/node_modules/@endo/marshal/src/deeplyFulfilled.js
@@ -3,15 +3,14 @@
 /// <reference types="ses"/>
 
 import { E } from '@endo/eventual-send';
-/**
- * @template T
- * @typedef {import('@endo/eventual-send').ERef<T>} ERef
- */
 import { isPromise } from '@endo/promise-kit';
 import { getTag, isObject } from './helpers/passStyle-helpers.js';
 import { makeTagged } from './makeTagged.js';
 import { passStyleOf } from './passStyleOf.js';
 
+/** @typedef {import('./types.js').Passable} Passable */
+/** @template T @typedef {import('@endo/eventual-send').ERef<T>} ERef */
+
 const { details: X, quote: q } = assert;
 const { ownKeys } = Reflect;
 const { fromEntries } = Object;
diff --git a/node_modules/@endo/marshal/src/dot-membrane.d.ts b/node_modules/@endo/marshal/src/dot-membrane.d.ts
new file mode 100644
index 0000000..e7c2079
--- /dev/null
+++ b/node_modules/@endo/marshal/src/dot-membrane.d.ts
@@ -0,0 +1,5 @@
+export function makeDotMembraneKit(target: any): {
+    proxy: any;
+    revoke: (reasonString: any) => void;
+};
+//# sourceMappingURL=dot-membrane.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@endo/marshal/src/dot-membrane.d.ts.map b/node_modules/@endo/marshal/src/dot-membrane.d.ts.map
new file mode 100644
index 0000000..2170b87
--- /dev/null
+++ b/node_modules/@endo/marshal/src/dot-membrane.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"dot-membrane.d.ts","sourceRoot":"","sources":["dot-membrane.js"],"names":[],"mappings":"AAoJO;;;EAMN"}
\ No newline at end of file
diff --git a/node_modules/@endo/marshal/src/dot-membrane.js b/node_modules/@endo/marshal/src/dot-membrane.js
index 6d23b7c..7f1f2fa 100644
--- a/node_modules/@endo/marshal/src/dot-membrane.js
+++ b/node_modules/@endo/marshal/src/dot-membrane.js
@@ -14,6 +14,8 @@ const { fromEntries } = Object;
 const { ownKeys } = Reflect;
 const { details: X } = assert;
 
+// TODO(erights): Add Converter type
+/** @param {any} [mirrorConverter] */
 const makeConverter = (mirrorConverter = undefined) => {
   /** @type {WeakMap<any,any>=} */
   let mineToYours = new WeakMap();
@@ -61,6 +63,7 @@ const makeConverter = (mirrorConverter = undefined) => {
         break;
       }
       case 'remotable': {
+        /** @param {PropertyKey} [optVerb] */
         const myMethodToYours = (optVerb = undefined) => (...yourArgs) => {
           // We use mineIf rather than mine so that mine is not accessible
           // after revocation. This gives the correct error behavior,
diff --git a/node_modules/@endo/marshal/src/helpers/copyArray.d.ts b/node_modules/@endo/marshal/src/helpers/copyArray.d.ts
new file mode 100644
index 0000000..c739632
--- /dev/null
+++ b/node_modules/@endo/marshal/src/helpers/copyArray.d.ts
@@ -0,0 +1,6 @@
+/**
+ *
+ * @type {import('./internal-types.js').PassStyleHelper}
+ */
+export const CopyArrayHelper: import('./internal-types.js').PassStyleHelper;
+//# sourceMappingURL=copyArray.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@endo/marshal/src/helpers/copyArray.d.ts.map b/node_modules/@endo/marshal/src/helpers/copyArray.d.ts.map
new file mode 100644
index 0000000..1e90066
--- /dev/null
+++ b/node_modules/@endo/marshal/src/helpers/copyArray.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"copyArray.d.ts","sourceRoot":"","sources":["copyArray.js"],"names":[],"mappings":"AAeA;;;GAGG;AACH,8BAFU,OAAO,qBAAqB,EAAE,eAAe,CA+BpD"}
\ No newline at end of file
diff --git a/node_modules/@endo/marshal/src/helpers/copyArray.js b/node_modules/@endo/marshal/src/helpers/copyArray.js
index f6ec450..372106b 100644
--- a/node_modules/@endo/marshal/src/helpers/copyArray.js
+++ b/node_modules/@endo/marshal/src/helpers/copyArray.js
@@ -2,9 +2,11 @@
 
 /// <reference types="ses"/>
 
-import '../types.js';
-import './internal-types.js';
-import { assertChecker, checkNormalProperty } from './passStyle-helpers.js';
+import {
+  assertChecker,
+  checkNormalProperty,
+  conditionChecker,
+} from './passStyle-helpers.js';
 
 const { details: X } = assert;
 const { getPrototypeOf } = Object;
@@ -13,12 +15,12 @@ const { isArray, prototype: arrayPrototype } = Array;
 
 /**
  *
- * @type {PassStyleHelper}
+ * @type {import('./internal-types.js').PassStyleHelper}
  */
 export const CopyArrayHelper = harden({
   styleName: 'copyArray',
 
-  canBeValid: (candidate, check = x => x) =>
+  canBeValid: (candidate, check = conditionChecker) =>
     check(isArray(candidate), X`Array expected: ${candidate}`),
 
   assertValid: (candidate, passStyleOfRecur) => {
diff --git a/node_modules/@endo/marshal/src/helpers/copyRecord.d.ts b/node_modules/@endo/marshal/src/helpers/copyRecord.d.ts
new file mode 100644
index 0000000..bf026b4
--- /dev/null
+++ b/node_modules/@endo/marshal/src/helpers/copyRecord.d.ts
@@ -0,0 +1,6 @@
+/**
+ *
+ * @type {import('./internal-types.js').PassStyleHelper}
+ */
+export const CopyRecordHelper: import('./internal-types.js').PassStyleHelper;
+//# sourceMappingURL=copyRecord.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@endo/marshal/src/helpers/copyRecord.d.ts.map b/node_modules/@endo/marshal/src/helpers/copyRecord.d.ts.map
new file mode 100644
index 0000000..46fb73a
--- /dev/null
+++ b/node_modules/@endo/marshal/src/helpers/copyRecord.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"copyRecord.d.ts","sourceRoot":"","sources":["copyRecord.js"],"names":[],"mappings":"AAmBA;;;GAGG;AACH,+BAFU,OAAO,qBAAqB,EAAE,eAAe,CAwCpD"}
\ No newline at end of file
diff --git a/node_modules/@endo/marshal/src/helpers/copyRecord.js b/node_modules/@endo/marshal/src/helpers/copyRecord.js
index 92dcf4b..b418881 100644
--- a/node_modules/@endo/marshal/src/helpers/copyRecord.js
+++ b/node_modules/@endo/marshal/src/helpers/copyRecord.js
@@ -6,11 +6,9 @@ import {
   assertChecker,
   canBeMethod,
   checkNormalProperty,
+  conditionChecker,
 } from './passStyle-helpers.js';
 
-import '../types.js';
-import './internal-types.js';
-
 const { details: X } = assert;
 const { ownKeys } = Reflect;
 const {
@@ -21,12 +19,12 @@ const {
 
 /**
  *
- * @type {PassStyleHelper}
+ * @type {import('./internal-types.js').PassStyleHelper}
  */
 export const CopyRecordHelper = harden({
   styleName: 'copyRecord',
 
-  canBeValid: (candidate, check = x => x) => {
+  canBeValid: (candidate, check = conditionChecker) => {
     const proto = getPrototypeOf(candidate);
     if (proto !== objectPrototype && proto !== null) {
       return check(false, X`Unexpected prototype for: ${candidate}`);
diff --git a/node_modules/@endo/marshal/src/helpers/environment-options.d.ts b/node_modules/@endo/marshal/src/helpers/environment-options.d.ts
new file mode 100644
index 0000000..1edb004
--- /dev/null
+++ b/node_modules/@endo/marshal/src/helpers/environment-options.d.ts
@@ -0,0 +1,3 @@
+export function getEnvironmentOption(optionName: string, defaultSetting?: string | undefined): string | undefined;
+export function setEnvironmentOption(optionName: string, setting?: string | undefined): void;
+//# sourceMappingURL=environment-options.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@endo/marshal/src/helpers/environment-options.d.ts.map b/node_modules/@endo/marshal/src/helpers/environment-options.d.ts.map
new file mode 100644
index 0000000..6819a00
--- /dev/null
+++ b/node_modules/@endo/marshal/src/helpers/environment-options.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"environment-options.d.ts","sourceRoot":"","sources":["environment-options.js"],"names":[],"mappings":"AA+DO,iDAHI,MAAM,mBACN,MAAM,kCAsChB;AAcM,iDAHI,MAAM,YACN,MAAM,oBAqBhB"}
\ No newline at end of file
diff --git a/node_modules/@endo/marshal/src/helpers/error.d.ts b/node_modules/@endo/marshal/src/helpers/error.d.ts
new file mode 100644
index 0000000..b083852
--- /dev/null
+++ b/node_modules/@endo/marshal/src/helpers/error.d.ts
@@ -0,0 +1,32 @@
+export function getErrorConstructor(name: any): ErrorConstructor | undefined;
+/**
+ * Validating error objects are passable raises a tension between security
+ * vs preserving diagnostic information. For errors, we need to remember
+ * the error itself exists to help us diagnose a bug that's likely more
+ * pressing than a validity bug in the error itself. Thus, whenever it is safe
+ * to do so, we prefer to let the error test succeed and to couch these
+ * complaints as notes on the error.
+ *
+ * To resolve this, such a malformed error object will still pass
+ * `canBeValid(err)` with no check, so marshal can use this for top
+ * level error to report from, even if it would not actually validate.
+ * Instead, the diagnostics that `assertError` would have reported are
+ * attached as notes to the malformed error. Thus, a malformed
+ * error is passable by itself, but not as part of a passable structure.
+ *
+ * @type {PassStyleHelper}
+ */
+export const ErrorHelper: PassStyleHelper;
+export function toPassableError(err: Error): Error;
+export type PassStyleHelper = {
+    styleName: import("../types.js").PassStyle;
+    /**
+     * If `canBeValid` returns true, then the candidate would
+     * definitely not be valid for any of the other helpers.
+     * `assertValid` still needs to be called to determine if it
+     * actually is valid.
+     */
+    canBeValid: (candidate: any, check?: import("../types.js").Checker | undefined) => boolean;
+    assertValid: (candidate: any, passStyleOfRecur: import("../types.js").PassStyleOf) => void;
+};
+//# sourceMappingURL=error.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@endo/marshal/src/helpers/error.d.ts.map b/node_modules/@endo/marshal/src/helpers/error.d.ts.map
new file mode 100644
index 0000000..ff4e5c8
--- /dev/null
+++ b/node_modules/@endo/marshal/src/helpers/error.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"error.d.ts","sourceRoot":"","sources":["error.js"],"names":[],"mappings":"AAyBO,6EAA+D;AAGtE;;;;;;;;;;;;;;;;GAgBG;AACH,0BAFU,eAAe,CAqDtB;AASI,qCAHI,KAAK,GACH,KAAK,CAYjB"}
\ No newline at end of file
diff --git a/node_modules/@endo/marshal/src/helpers/error.js b/node_modules/@endo/marshal/src/helpers/error.js
index b6fa373..57372fe 100644
--- a/node_modules/@endo/marshal/src/helpers/error.js
+++ b/node_modules/@endo/marshal/src/helpers/error.js
@@ -2,9 +2,9 @@
 
 /// <reference types="ses"/>
 
-import '../types.js';
-import './internal-types.js';
-import { assertChecker } from './passStyle-helpers.js';
+import { assertChecker, conditionChecker } from './passStyle-helpers.js';
+
+/** @typedef {import('./internal-types.js').PassStyleHelper} PassStyleHelper */
 
 const { details: X } = assert;
 const { getPrototypeOf, getOwnPropertyDescriptors } = Object;
@@ -46,7 +46,7 @@ harden(getErrorConstructor);
 export const ErrorHelper = harden({
   styleName: 'error',
 
-  canBeValid: (candidate, check = x => x) => {
+  canBeValid: (candidate, check = conditionChecker) => {
     // TODO: Need a better test than instanceof
     if (!(candidate instanceof Error)) {
       return check(false, X`Error expected: ${candidate}`);
diff --git a/node_modules/@endo/marshal/src/helpers/internal-types.d.ts b/node_modules/@endo/marshal/src/helpers/internal-types.d.ts
new file mode 100644
index 0000000..fb7f142
--- /dev/null
+++ b/node_modules/@endo/marshal/src/helpers/internal-types.d.ts
@@ -0,0 +1,26 @@
+export type Checker = (cond: boolean, details?: any) => boolean;
+export type PassStyle = "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "null" | "copyRecord" | "copyArray" | "tagged" | "remotable" | "error" | "promise";
+export type PassStyleOf = (passable: any) => import("../types.js").PassStyle;
+/**
+ * The PassStyleHelper are only used to make a `passStyleOf` function.
+ * Thus, it should not depend on an ambient one. Rather, each helper should be
+ * pure, and get its `passStyleOf` or similar function from its caller.
+ *
+ * For those methods that have a last `passStyleOf` or `passStyleOfRecur`,
+ * they must defend against the other arguments being malicious, but may
+ * *assume* that `passStyleOfRecur` does what it is supposed to do.
+ * Each such method is not trying to defend itself against a malicious
+ * `passStyleOfRecur`, though it may defend against some accidents.
+ */
+export type PassStyleHelper = {
+    styleName: PassStyle;
+    /**
+     * If `canBeValid` returns true, then the candidate would
+     * definitely not be valid for any of the other helpers.
+     * `assertValid` still needs to be called to determine if it
+     * actually is valid.
+     */
+    canBeValid: (candidate: any, check?: import("../types.js").Checker | undefined) => boolean;
+    assertValid: (candidate: any, passStyleOfRecur: PassStyleOf) => void;
+};
+//# sourceMappingURL=internal-types.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@endo/marshal/src/helpers/internal-types.d.ts.map b/node_modules/@endo/marshal/src/helpers/internal-types.d.ts.map
new file mode 100644
index 0000000..44d5c80
--- /dev/null
+++ b/node_modules/@endo/marshal/src/helpers/internal-types.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"internal-types.d.ts","sourceRoot":"","sources":["internal-types.js"],"names":[],"mappings":";;;;;;;;;;;;;;;eAuBc,SAAS;;;;;;;4BAEG,GAAG,wDAAsB,OAAO;6BAMhC,GAAG,oBACI,WAAW,KACzB,IAAI"}
\ No newline at end of file
diff --git a/node_modules/@endo/marshal/src/helpers/internal-types.js b/node_modules/@endo/marshal/src/helpers/internal-types.js
index c813fe8..5338fa0 100644
--- a/node_modules/@endo/marshal/src/helpers/internal-types.js
+++ b/node_modules/@endo/marshal/src/helpers/internal-types.js
@@ -2,6 +2,12 @@
 
 /// <reference path="../extra-types.d.ts" />
 
+export {};
+
+/** @typedef {import('../types.js').Checker} Checker */
+/** @typedef {import('../types.js').PassStyle} PassStyle */
+/** @typedef {import('../types.js').PassStyleOf} PassStyleOf */
+
 /**
  * The PassStyleHelper are only used to make a `passStyleOf` function.
  * Thus, it should not depend on an ambient one. Rather, each helper should be
diff --git a/node_modules/@endo/marshal/src/helpers/iter-helpers.d.ts b/node_modules/@endo/marshal/src/helpers/iter-helpers.d.ts
new file mode 100644
index 0000000..b82d00f
--- /dev/null
+++ b/node_modules/@endo/marshal/src/helpers/iter-helpers.d.ts
@@ -0,0 +1,3 @@
+export function mapIterable<T, U>(baseIterable: Iterable<T>, func: (value: T) => U): Iterable<U>;
+export function filterIterable<T>(baseIterable: Iterable<T>, pred: (value: T) => boolean): Iterable<T>;
+//# sourceMappingURL=iter-helpers.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@endo/marshal/src/helpers/iter-helpers.d.ts.map b/node_modules/@endo/marshal/src/helpers/iter-helpers.d.ts.map
new file mode 100644
index 0000000..dea3d7c
--- /dev/null
+++ b/node_modules/@endo/marshal/src/helpers/iter-helpers.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"iter-helpers.d.ts","sourceRoot":"","sources":["iter-helpers.js"],"names":[],"mappings":"AAeO,iGAaH;AAcG,iFAHkB,OAAO,eAoB5B"}
\ No newline at end of file
diff --git a/node_modules/@endo/marshal/src/helpers/passStyle-helpers.d.ts b/node_modules/@endo/marshal/src/helpers/passStyle-helpers.d.ts
new file mode 100644
index 0000000..aacdec9
--- /dev/null
+++ b/node_modules/@endo/marshal/src/helpers/passStyle-helpers.d.ts
@@ -0,0 +1,23 @@
+/** @type {Checker} */
+export const conditionChecker: Checker;
+export function hasOwnPropertyOf(obj: any, prop: any): any;
+export function isObject(val: any): boolean;
+export const PASS_STYLE: unique symbol;
+export function canBeMethod(func: any): boolean;
+/**
+ * Below we have a series of predicate functions and their (curried) assertion
+ * functions. The semantics of the assertion function is just to assert that
+ * the corresponding predicate function would have returned true. But it
+ * reproduces the internal tests so failures can give a better error message.
+ *
+ * @type {Checker}
+ */
+export const assertChecker: Checker;
+export function checkNormalProperty(candidate: any, propertyName: string | number | symbol, nameType?: string | undefined, shouldBeEnumerable?: boolean | undefined, check?: Checker | undefined): boolean;
+export function getTag(tagRecord: any): any;
+export function checkTagRecord(tagRecord: {
+    [PASS_STYLE]: string;
+}, passStyle: PassStyle, check?: import("../types.js").Checker | undefined): boolean;
+export type Checker = (cond: boolean, details?: any) => boolean;
+export type PassStyle = "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "null" | "copyRecord" | "copyArray" | "tagged" | "remotable" | "error" | "promise";
+//# sourceMappingURL=passStyle-helpers.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@endo/marshal/src/helpers/passStyle-helpers.d.ts.map b/node_modules/@endo/marshal/src/helpers/passStyle-helpers.d.ts.map
new file mode 100644
index 0000000..c6e2a35
--- /dev/null
+++ b/node_modules/@endo/marshal/src/helpers/passStyle-helpers.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"passStyle-helpers.d.ts","sourceRoot":"","sources":["passStyle-helpers.js"],"names":[],"mappings":"AAeA,sBAAsB;AACtB,+BADW,OAAO,CACmD;AAG9D,2DACmC;AAGnC,4CAA2C;AAGlD,uCAAkD;AAe3C,kCAHI,GAAG,GACD,OAAO,CAGiC;AAGrD;;;;;;;GAOG;AACH,4BAFU,OAAO,CAKf;AAWK,kEANI,MAAM,GAAC,MAAM,GAAC,MAAM,aACpB,MAAM,mCACN,OAAO,sBACP,OAAO,eACL,OAAO,CAqCnB;AAGM,4CAAyD;AASzD,0CALI;IAAE,YAAY,EAAE,MAAM,CAAA;CAAE,aACxB,SAAS,sDAEP,OAAO,CAgCnB"}
\ No newline at end of file
diff --git a/node_modules/@endo/marshal/src/helpers/passStyle-helpers.js b/node_modules/@endo/marshal/src/helpers/passStyle-helpers.js
index 5eaab77..02c982d 100644
--- a/node_modules/@endo/marshal/src/helpers/passStyle-helpers.js
+++ b/node_modules/@endo/marshal/src/helpers/passStyle-helpers.js
@@ -2,8 +2,8 @@
 
 /// <reference types="ses"/>
 
-import '../types.js';
-import './internal-types.js';
+/** @typedef {import('../types.js').Checker} Checker */
+/** @typedef {import('../types.js').PassStyle} PassStyle */
 
 const { details: X, quote: q } = assert;
 const {
@@ -13,6 +13,10 @@ const {
 const { apply } = Reflect;
 const { isArray } = Array;
 
+/** @type {Checker} */
+export const conditionChecker = (cond, _details = undefined) => cond;
+harden(conditionChecker);
+
 export const hasOwnPropertyOf = (obj, prop) =>
   apply(objectHasOwnProperty, obj, [prop]);
 harden(hasOwnPropertyOf);
diff --git a/node_modules/@endo/marshal/src/helpers/remotable.d.ts b/node_modules/@endo/marshal/src/helpers/remotable.d.ts
new file mode 100644
index 0000000..d2b1a6e
--- /dev/null
+++ b/node_modules/@endo/marshal/src/helpers/remotable.d.ts
@@ -0,0 +1,25 @@
+export const ALLOW_IMPLICIT_REMOTABLES: boolean;
+export function assertIface(iface: InterfaceSpec): boolean;
+/** @type {MarshalGetInterfaceOf} */
+export const getInterfaceOf: MarshalGetInterfaceOf;
+/**
+ *
+ * @type {PassStyleHelper}
+ */
+export const RemotableHelper: PassStyleHelper;
+export type Checker = (cond: boolean, details?: any) => boolean;
+export type InterfaceSpec = string;
+export type MarshalGetInterfaceOf = (maybeRemotable: any) => string | undefined;
+export type PassStyleHelper = {
+    styleName: import("../types.js").PassStyle;
+    /**
+     * If `canBeValid` returns true, then the candidate would
+     * definitely not be valid for any of the other helpers.
+     * `assertValid` still needs to be called to determine if it
+     * actually is valid.
+     */
+    canBeValid: (candidate: any, check?: import("../types.js").Checker | undefined) => boolean;
+    assertValid: (candidate: any, passStyleOfRecur: import("../types.js").PassStyleOf) => void;
+};
+export type Remotable = any;
+//# sourceMappingURL=remotable.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@endo/marshal/src/helpers/remotable.d.ts.map b/node_modules/@endo/marshal/src/helpers/remotable.d.ts.map
new file mode 100644
index 0000000..bda1a9b
--- /dev/null
+++ b/node_modules/@endo/marshal/src/helpers/remotable.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"remotable.d.ts","sourceRoot":"","sources":["remotable.js"],"names":[],"mappings":"AAwCA,gDACwE;AAyBjE,mCAFI,aAAa,WAE4C;AAuGpE,oCAAoC;AACpC,6BADW,qBAAqB,CAY9B;AAGF;;;GAGG;AACH,8BAFU,eAAe,CAsEtB"}
\ No newline at end of file
diff --git a/node_modules/@endo/marshal/src/helpers/remotable.js b/node_modules/@endo/marshal/src/helpers/remotable.js
index e563566..c40791d 100644
--- a/node_modules/@endo/marshal/src/helpers/remotable.js
+++ b/node_modules/@endo/marshal/src/helpers/remotable.js
@@ -2,10 +2,9 @@
 
 /// <reference types="ses"/>
 
-import '../types.js';
-import './internal-types.js';
 import {
   assertChecker,
+  conditionChecker,
   canBeMethod,
   hasOwnPropertyOf,
   PASS_STYLE,
@@ -15,6 +14,12 @@ import {
 } from './passStyle-helpers.js';
 import { getEnvironmentOption } from './environment-options.js';
 
+/** @typedef {import('../types.js').Checker} Checker */
+/** @typedef {import('../types.js').InterfaceSpec} InterfaceSpec */
+/** @typedef {import('../types.js').MarshalGetInterfaceOf} MarshalGetInterfaceOf */
+/** @typedef {import('./internal-types.js').PassStyleHelper} PassStyleHelper */
+/** @typedef {import('../types.js').Remotable} Remotable */
+
 const { details: X, quote: q } = assert;
 const { ownKeys } = Reflect;
 const { prototype: functionPrototype } = Function;
@@ -40,7 +45,7 @@ export const ALLOW_IMPLICIT_REMOTABLES =
  * @param {InterfaceSpec} iface
  * @param {Checker=} check
  */
-const checkIface = (iface, check = x => x) => {
+const checkIface = (iface, check = conditionChecker) => {
   return (
     // TODO other possible ifaces, once we have third party veracity
     check(
@@ -67,7 +72,7 @@ harden(assertIface);
  * @param {Checker} [check]
  * @returns {boolean}
  */
-const checkRemotableProtoOf = (original, check = x => x) => {
+const checkRemotableProtoOf = (original, check = conditionChecker) => {
   /**
    * TODO: It would be nice to typedef this shape, but we can't declare a type
    * with PASS_STYLE from JSDoc.
@@ -139,7 +144,7 @@ const checkRemotableProtoOf = (original, check = x => x) => {
  * @param {Checker} [check]
  * @returns {boolean}
  */
-const checkRemotable = (val, check = x => x) => {
+const checkRemotable = (val, check = conditionChecker) => {
   const not = (cond, details) => !check(cond, details);
   if (not(isFrozen(val), X`cannot serialize non-frozen objects like ${val}`)) {
     return false;
@@ -184,7 +189,7 @@ harden(getInterfaceOf);
 export const RemotableHelper = harden({
   styleName: 'remotable',
 
-  canBeValid: (candidate, check = x => x) => {
+  canBeValid: (candidate, check = conditionChecker) => {
     if (
       !(
         check(
diff --git a/node_modules/@endo/marshal/src/helpers/symbol.d.ts b/node_modules/@endo/marshal/src/helpers/symbol.d.ts
new file mode 100644
index 0000000..a165f89
--- /dev/null
+++ b/node_modules/@endo/marshal/src/helpers/symbol.d.ts
@@ -0,0 +1,6 @@
+export function isPassableSymbol(sym: any): boolean;
+export function assertPassableSymbol(sym: any): void;
+export function nameForPassableSymbol(sym: symbol): string | undefined;
+export const AtAtPrefixPattern: RegExp;
+export function passableSymbolForName(name: string): symbol | undefined;
+//# sourceMappingURL=symbol.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@endo/marshal/src/helpers/symbol.d.ts.map b/node_modules/@endo/marshal/src/helpers/symbol.d.ts.map
new file mode 100644
index 0000000..98de96c
--- /dev/null
+++ b/node_modules/@endo/marshal/src/helpers/symbol.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"symbol.d.ts","sourceRoot":"","sources":["symbol.js"],"names":[],"mappings":"AAmCO,sCAHI,GAAG,GACD,OAAO,CAIuD;AAGpE,qDAIJ;AAwBI,2CAHI,MAAM,GACJ,MAAM,aAWlB;AAGD,uCAA4C;AAsBrC,4CAHI,MAAM,GACJ,MAAM,aAoBlB"}
\ No newline at end of file
diff --git a/node_modules/@endo/marshal/src/helpers/tagged.d.ts b/node_modules/@endo/marshal/src/helpers/tagged.d.ts
new file mode 100644
index 0000000..fe554c0
--- /dev/null
+++ b/node_modules/@endo/marshal/src/helpers/tagged.d.ts
@@ -0,0 +1,6 @@
+/**
+ *
+ * @type {import('./internal-types.js').PassStyleHelper}
+ */
+export const TaggedHelper: import('./internal-types.js').PassStyleHelper;
+//# sourceMappingURL=tagged.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@endo/marshal/src/helpers/tagged.d.ts.map b/node_modules/@endo/marshal/src/helpers/tagged.d.ts.map
new file mode 100644
index 0000000..d2745db
--- /dev/null
+++ b/node_modules/@endo/marshal/src/helpers/tagged.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"tagged.d.ts","sourceRoot":"","sources":["tagged.js"],"names":[],"mappings":"AAgBA;;;GAGG;AACH,2BAFU,OAAO,qBAAqB,EAAE,eAAe,CAiCpD"}
\ No newline at end of file
diff --git a/node_modules/@endo/marshal/src/helpers/tagged.js b/node_modules/@endo/marshal/src/helpers/tagged.js
index 6bfdf56..0000a53 100644
--- a/node_modules/@endo/marshal/src/helpers/tagged.js
+++ b/node_modules/@endo/marshal/src/helpers/tagged.js
@@ -7,23 +7,21 @@ import {
   checkTagRecord,
   PASS_STYLE,
   checkNormalProperty,
+  conditionChecker,
 } from './passStyle-helpers.js';
 
-import '../types.js';
-import './internal-types.js';
-
 const { details: X } = assert;
 const { ownKeys } = Reflect;
 const { getPrototypeOf, prototype: objectPrototype } = Object;
 
 /**
  *
- * @type {PassStyleHelper}
+ * @type {import('./internal-types.js').PassStyleHelper}
  */
 export const TaggedHelper = harden({
   styleName: 'tagged',
 
-  canBeValid: (candidate, check = x => x) =>
+  canBeValid: (candidate, check = conditionChecker) =>
     checkTagRecord(candidate, 'tagged', check),
 
   assertValid: (candidate, passStyleOfRecur) => {
diff --git a/node_modules/@endo/marshal/src/make-far.d.ts b/node_modules/@endo/marshal/src/make-far.d.ts
new file mode 100644
index 0000000..8eb757c
--- /dev/null
+++ b/node_modules/@endo/marshal/src/make-far.d.ts
@@ -0,0 +1,5 @@
+export function Remotable(iface?: string | undefined, props?: undefined, remotable?: any): any;
+export function Far<T>(farName: string, remotable?: T | undefined): T;
+export function ToFarFunction(farName: string, func: (...args: any[]) => any): (...args: any[]) => any;
+export type InterfaceSpec = string;
+//# sourceMappingURL=make-far.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@endo/marshal/src/make-far.d.ts.map b/node_modules/@endo/marshal/src/make-far.d.ts.map
new file mode 100644
index 0000000..bfb414f
--- /dev/null
+++ b/node_modules/@endo/marshal/src/make-far.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"make-far.d.ts","sourceRoot":"","sources":["make-far.js"],"names":[],"mappings":"AAwFO,8DALI,SAAS,cAET,GAAG,GACD,GAAG,CA+Cf;AAYM,gCALI,MAAM,gCAQhB;AAeM,uCAJI,MAAM,kBAEI,GAAG,EAAE,KAAK,GAAG,aAAb,GAAG,EAAE,KAAK,GAAG,CAOjC"}
\ No newline at end of file
diff --git a/node_modules/@endo/marshal/src/make-far.js b/node_modules/@endo/marshal/src/make-far.js
index ab431a0..697ac76 100644
--- a/node_modules/@endo/marshal/src/make-far.js
+++ b/node_modules/@endo/marshal/src/make-far.js
@@ -10,6 +10,8 @@ import {
 } from './helpers/remotable.js';
 import { pureCopy } from './pureCopy.js';
 
+/** @typedef {import('./types.js').InterfaceSpec} InterfaceSpec */
+
 const { quote: q, details: X } = assert;
 
 const { prototype: functionPrototype } = Function;
@@ -81,8 +83,8 @@ const assertCanBeRemotable = candidate =>
  * Carol's `iface` as misrepresented by VatA.
  * @param {undefined} [props=undefined] Currently may only be undefined.
  * That plan is that own-properties are copied to the remotable
- * @param {object} [remotable={}] The object used as the remotable
- * @returns {object} remotable, modified for debuggability
+ * @param {any} [remotable={}] The object used as the remotable
+ * @returns {any} remotable, modified for debuggability
  */
 export const Remotable = (
   iface = 'Remotable',
diff --git a/node_modules/@endo/marshal/src/makeTagged.d.ts b/node_modules/@endo/marshal/src/makeTagged.d.ts
new file mode 100644
index 0000000..d34ae7c
--- /dev/null
+++ b/node_modules/@endo/marshal/src/makeTagged.d.ts
@@ -0,0 +1,2 @@
+export function makeTagged(tag: any, payload: any): any;
+//# sourceMappingURL=makeTagged.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@endo/marshal/src/makeTagged.d.ts.map b/node_modules/@endo/marshal/src/makeTagged.d.ts.map
new file mode 100644
index 0000000..b1b0c3d
--- /dev/null
+++ b/node_modules/@endo/marshal/src/makeTagged.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"makeTagged.d.ts","sourceRoot":"","sources":["makeTagged.js"],"names":[],"mappings":"AAUO,wDAcN"}
\ No newline at end of file
diff --git a/node_modules/@endo/marshal/src/marshal-justin.d.ts b/node_modules/@endo/marshal/src/marshal-justin.d.ts
new file mode 100644
index 0000000..16b9c49
--- /dev/null
+++ b/node_modules/@endo/marshal/src/marshal-justin.d.ts
@@ -0,0 +1,46 @@
+export type Encoding = string | number | boolean | import("./types.js").EncodingClass<"NaN"> | import("./types.js").EncodingClass<"undefined"> | import("./types.js").EncodingClass<"Infinity"> | import("./types.js").EncodingClass<"-Infinity"> | (import("./types.js").EncodingClass<"bigint"> & {
+    digits: string;
+}) | import("./types.js").EncodingClass<"@@asyncIterator"> | (import("./types.js").EncodingClass<"symbol"> & {
+    name: string;
+}) | (import("./types.js").EncodingClass<"error"> & {
+    name: string;
+    message: string;
+    errorId?: string | undefined;
+}) | (import("./types.js").EncodingClass<"slot"> & {
+    index: number;
+    iface?: string | undefined;
+}) | (import("./types.js").EncodingClass<"hilbert"> & {
+    original: import("./types.js").Encoding;
+    rest?: string | number | boolean | import("./types.js").EncodingClass<"NaN"> | import("./types.js").EncodingClass<"undefined"> | import("./types.js").EncodingClass<"Infinity"> | import("./types.js").EncodingClass<"-Infinity"> | (import("./types.js").EncodingClass<"bigint"> & {
+        digits: string;
+    }) | import("./types.js").EncodingClass<"@@asyncIterator"> | (import("./types.js").EncodingClass<"symbol"> & {
+        name: string;
+    }) | (import("./types.js").EncodingClass<"error"> & {
+        name: string;
+        message: string;
+        errorId?: string | undefined;
+    }) | (import("./types.js").EncodingClass<"slot"> & {
+        index: number;
+        iface?: string | undefined;
+    }) | (import("./types.js").EncodingClass<"hilbert"> & any) | (import("./types.js").EncodingClass<"tagged"> & {
+        tag: string;
+        payload: import("./types.js").Encoding;
+    }) | import("./types.js").EncodingRecord | NestedArray<import("./types.js").EncodingElement> | null | undefined;
+}) | (import("./types.js").EncodingClass<"tagged"> & {
+    tag: string;
+    payload: import("./types.js").Encoding;
+}) | import("./types.js").EncodingRecord | NestedArray<import("./types.js").EncodingElement> | null;
+export type Indenter = {
+    open: (openBracket: string) => number;
+    line: () => number;
+    next: (token: string) => number;
+    close: (closeBracket: string) => number;
+    done: () => string;
+};
+/**
+ * @param {Encoding} encoding
+ * @param {boolean=} shouldIndent
+ * @returns {string}
+ */
+export function decodeToJustin(encoding: Encoding, shouldIndent?: boolean | undefined): string;
+//# sourceMappingURL=marshal-justin.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@endo/marshal/src/marshal-justin.d.ts.map b/node_modules/@endo/marshal/src/marshal-justin.d.ts.map
new file mode 100644
index 0000000..71e2f41
--- /dev/null
+++ b/node_modules/@endo/marshal/src/marshal-justin.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"marshal-justin.d.ts","sourceRoot":"","sources":["marshal-justin.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wBAoB4B,MAAM,KAAK,MAAM;UAC/B,MAAM,MAAM;kBACJ,MAAM,KAAK,MAAM;0BACV,MAAM,KAAK,MAAM;UAChC,MAAM,MAAM;;AA4F1B;;;;GAIG;AACH,yCAJW,QAAQ,iBACR,OAAO,eACL,MAAM,CAySlB"}
\ No newline at end of file
diff --git a/node_modules/@endo/marshal/src/marshal-justin.js b/node_modules/@endo/marshal/src/marshal-justin.js
index d32c27f..f000651 100644
--- a/node_modules/@endo/marshal/src/marshal-justin.js
+++ b/node_modules/@endo/marshal/src/marshal-justin.js
@@ -5,11 +5,12 @@
 import { Nat } from '@endo/nat';
 import { QCLASS } from './marshal.js';
 
-import './types.js';
 import { getErrorConstructor } from './helpers/error.js';
 import { isObject } from './helpers/passStyle-helpers.js';
 import { AtAtPrefixPattern, passableSymbolForName } from './helpers/symbol.js';
 
+/** @typedef {import('./types.js').Encoding} Encoding */
+
 const { ownKeys } = Reflect;
 const { isArray } = Array;
 const { stringify: quote } = JSON;
@@ -396,7 +397,9 @@ const decodeToJustin = (encoding, shouldIndent = false) => {
         return out.close(']');
       }
     } else {
-      const names = ownKeys(rawTree);
+      // rawTree is an `EncodingRecord` which only has string keys,
+      // but since ownKeys is not generic, it can't propagate that
+      const names = /** @type {string[]} */ (ownKeys(rawTree));
       if (names.length === 0) {
         return out.next('{}');
       } else {
diff --git a/node_modules/@endo/marshal/src/marshal-stringify.d.ts b/node_modules/@endo/marshal/src/marshal-stringify.d.ts
new file mode 100644
index 0000000..f747ea1
--- /dev/null
+++ b/node_modules/@endo/marshal/src/marshal-stringify.d.ts
@@ -0,0 +1,12 @@
+export type OnlyData = any;
+/**
+ * @param {OnlyData} val
+ * @returns {string}
+ */
+export function stringify(val: OnlyData): string;
+/**
+ * @param {string} str
+ * @returns {OnlyData}
+ */
+export function parse(str: string): OnlyData;
+//# sourceMappingURL=marshal-stringify.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@endo/marshal/src/marshal-stringify.d.ts.map b/node_modules/@endo/marshal/src/marshal-stringify.d.ts.map
new file mode 100644
index 0000000..26b328c
--- /dev/null
+++ b/node_modules/@endo/marshal/src/marshal-stringify.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"marshal-stringify.d.ts","sourceRoot":"","sources":["marshal-stringify.js"],"names":[],"mappings":";AAkCA;;;GAGG;AACH,+BAHW,QAAQ,GACN,MAAM,CAEyB;AAG5C;;;GAGG;AACH,2BAHW,MAAM,GACJ,QAAQ,CAQlB"}
\ No newline at end of file
diff --git a/node_modules/@endo/marshal/src/marshal-stringify.js b/node_modules/@endo/marshal/src/marshal-stringify.js
index d54c655..d657c14 100644
--- a/node_modules/@endo/marshal/src/marshal-stringify.js
+++ b/node_modules/@endo/marshal/src/marshal-stringify.js
@@ -3,15 +3,15 @@
 
 import { makeMarshal } from './marshal.js';
 
-import './types.js';
+/** @typedef {import('./types.js').OnlyData} OnlyData */
 
 const { details: X } = assert;
 
-/** @type {ConvertValToSlot<any>} */
+/** @type {import('./types.js').ConvertValToSlot<any>} */
 const doNotConvertValToSlot = val =>
   assert.fail(X`Marshal's stringify rejects presences and promises ${val}`);
 
-/** @type {ConvertSlotToVal<any>} */
+/** @type {import('./types.js').ConvertSlotToVal<any>} */
 const doNotConvertSlotToVal = (slot, _iface) =>
   assert.fail(X`Marshal's parse must not encode any slots ${slot}`);
 
diff --git a/node_modules/@endo/marshal/src/marshal.d.ts b/node_modules/@endo/marshal/src/marshal.d.ts
new file mode 100644
index 0000000..d32a75c
--- /dev/null
+++ b/node_modules/@endo/marshal/src/marshal.d.ts
@@ -0,0 +1,76 @@
+export function makeMarshal<Slot>(convertValToSlot?: import("./types.js").ConvertValToSlot<Slot> | undefined, convertSlotToVal?: import("./types.js").ConvertSlotToVal<Slot> | undefined, { errorTagging, marshalName, errorIdNum, marshalSaveError, }?: import("./types.js").MakeMarshalOptions | undefined): {
+    serialize: import("./types.js").Serialize<Slot>;
+    unserialize: import("./types.js").Unserialize<Slot>;
+};
+export type MakeMarshalOptions = {
+    /**
+     * controls whether serialized errors
+     * also carry tagging information, made from `marshalName` and numbers
+     * generated (currently by counting) starting at `errorIdNum`. The
+     * `errorTagging` option defaults to `'on'`. Serialized
+     * errors are also logged to `marshalSaveError` only if tagging is `'on'`.
+     */
+    errorTagging?: "on" | "off" | undefined;
+    /**
+     * Used to identify sent errors.
+     */
+    marshalName?: string | undefined;
+    /**
+     * Ascending numbers staring from here
+     * identify the sending of errors relative to this marshal instance.
+     */
+    errorIdNum?: number | undefined;
+    /**
+     * If `errorTagging` is
+     * `'on'`, then errors serialized by this marshal instance are also
+     * logged by calling `marshalSaveError` *after* `assert.note` associated
+     * that error with its errorId. Thus, if `marshalSaveError` in turn logs
+     * to the normal console, which is the default, then the console will
+     * show that note showing the associated errorId.
+     */
+    marshalSaveError?: ((err: Error) => void) | undefined;
+};
+export type ConvertSlotToVal<Slot> = (slot: Slot, iface?: string | undefined) => any;
+export type ConvertValToSlot<Slot> = (val: any) => Slot;
+export type Serialize<Slot> = (val: any) => import("./types.js").CapData<Slot>;
+export type Unserialize<Slot> = (data: import("./types.js").CapData<Slot>) => any;
+export type Passable = any;
+export type InterfaceSpec = string;
+export type Encoding = string | number | boolean | import("./types.js").EncodingClass<"NaN"> | import("./types.js").EncodingClass<"undefined"> | import("./types.js").EncodingClass<"Infinity"> | import("./types.js").EncodingClass<"-Infinity"> | (import("./types.js").EncodingClass<"bigint"> & {
+    digits: string;
+}) | import("./types.js").EncodingClass<"@@asyncIterator"> | (import("./types.js").EncodingClass<"symbol"> & {
+    name: string;
+}) | (import("./types.js").EncodingClass<"error"> & {
+    name: string;
+    message: string;
+    errorId?: string | undefined;
+}) | (import("./types.js").EncodingClass<"slot"> & {
+    index: number;
+    iface?: string | undefined;
+}) | (import("./types.js").EncodingClass<"hilbert"> & {
+    original: import("./types.js").Encoding;
+    rest?: string | number | boolean | import("./types.js").EncodingClass<"NaN"> | import("./types.js").EncodingClass<"undefined"> | import("./types.js").EncodingClass<"Infinity"> | import("./types.js").EncodingClass<"-Infinity"> | (import("./types.js").EncodingClass<"bigint"> & {
+        digits: string;
+    }) | import("./types.js").EncodingClass<"@@asyncIterator"> | (import("./types.js").EncodingClass<"symbol"> & {
+        name: string;
+    }) | (import("./types.js").EncodingClass<"error"> & {
+        name: string;
+        message: string;
+        errorId?: string | undefined;
+    }) | (import("./types.js").EncodingClass<"slot"> & {
+        index: number;
+        iface?: string | undefined;
+    }) | (import("./types.js").EncodingClass<"hilbert"> & any) | (import("./types.js").EncodingClass<"tagged"> & {
+        tag: string;
+        payload: import("./types.js").Encoding;
+    }) | import("./types.js").EncodingRecord | NestedArray<import("./types.js").EncodingElement> | null | undefined;
+}) | (import("./types.js").EncodingClass<"tagged"> & {
+    tag: string;
+    payload: import("./types.js").Encoding;
+}) | import("./types.js").EncodingRecord | NestedArray<import("./types.js").EncodingElement> | null;
+/**
+ * Special property name that indicates an encoding that needs special
+ * decoding.
+ */
+export const QCLASS: "@qclass";
+//# sourceMappingURL=marshal.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@endo/marshal/src/marshal.d.ts.map b/node_modules/@endo/marshal/src/marshal.d.ts.map
new file mode 100644
index 0000000..f6d113e
--- /dev/null
+++ b/node_modules/@endo/marshal/src/marshal.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"marshal.d.ts","sourceRoot":"","sources":["marshal.js"],"names":[],"mappings":"AAuDO;;;EAgdN;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAleD;;;GAGG;AACH,+BAAyB"}
\ No newline at end of file
diff --git a/node_modules/@endo/marshal/src/marshal.js b/node_modules/@endo/marshal/src/marshal.js
index fb24743..5df3748 100644
--- a/node_modules/@endo/marshal/src/marshal.js
+++ b/node_modules/@endo/marshal/src/marshal.js
@@ -5,7 +5,6 @@
 import { Nat } from '@endo/nat';
 import { assertPassable, passStyleOf } from './passStyleOf.js';
 
-import './types.js';
 import { getInterfaceOf } from './helpers/remotable.js';
 import { ErrorHelper, getErrorConstructor } from './helpers/error.js';
 import { makeTagged } from './makeTagged.js';
@@ -16,6 +15,15 @@ import {
   passableSymbolForName,
 } from './helpers/symbol.js';
 
+/** @typedef {import('./types.js').MakeMarshalOptions} MakeMarshalOptions */
+/** @template Slot @typedef {import('./types.js').ConvertSlotToVal<Slot>} ConvertSlotToVal */
+/** @template Slot @typedef {import('./types.js').ConvertValToSlot<Slot>} ConvertValToSlot */
+/** @template Slot @typedef {import('./types.js').Serialize<Slot>} Serialize */
+/** @template Slot @typedef {import('./types.js').Unserialize<Slot>} Unserialize */
+/** @typedef {import('./types.js').Passable} Passable */
+/** @typedef {import('./types.js').InterfaceSpec} InterfaceSpec */
+/** @typedef {import('./types.js').Encoding} Encoding */
+
 const { ownKeys } = Reflect;
 const { isArray } = Array;
 const {
@@ -34,14 +42,18 @@ const { details: X, quote: q } = assert;
 const QCLASS = '@qclass';
 export { QCLASS };
 
+/** @type {ConvertValToSlot<any>} */
 const defaultValToSlotFn = x => x;
+/** @type {ConvertSlotToVal<any>} */
 const defaultSlotToValFn = (x, _) => x;
 
 /**
  * @template Slot
- * @type {MakeMarshal<Slot>}
+ * @param {ConvertValToSlot<Slot>} [convertValToSlot]
+ * @param {ConvertSlotToVal<Slot>} [convertSlotToVal]
+ * @param {MakeMarshalOptions} [options]
  */
-export function makeMarshal(
+export const makeMarshal = (
   convertValToSlot = defaultValToSlotFn,
   convertSlotToVal = defaultSlotToValFn,
   {
@@ -55,7 +67,7 @@ export function makeMarshal(
     marshalSaveError = err =>
       console.log('Temporary logging of sent error', err),
   } = {},
-) {
+) => {
   assert.typeof(marshalName, 'string');
   assert(
     errorTagging === 'on' || errorTagging === 'off',
@@ -67,7 +79,6 @@ export function makeMarshal(
   };
 
   /**
-   * @template Slot
    * @type {Serialize<Slot>}
    */
   const serialize = root => {
@@ -382,7 +393,7 @@ export function makeMarshal(
           }
           case 'symbol': {
             const { name } = rawTree;
-            return passableSymbolForName(name);
+            return passableSymbolForName(`${name}`);
           }
 
           case 'tagged': {
@@ -451,6 +462,7 @@ export function makeMarshal(
 
           default: {
             assert(
+              // @ts-ignore exhaustive check should make condition true
               qclass !== 'ibid',
               X`The protocol no longer supports ibid encoding: ${rawTree}.`,
             );
@@ -481,7 +493,6 @@ export function makeMarshal(
   };
 
   /**
-   * @template Slot
    * @type {Unserialize<Slot>}
    */
   const unserialize = data => {
@@ -506,4 +517,4 @@ export function makeMarshal(
     serialize,
     unserialize,
   });
-}
+};
diff --git a/node_modules/@endo/marshal/src/passStyleOf.d.ts b/node_modules/@endo/marshal/src/passStyleOf.d.ts
new file mode 100644
index 0000000..0b87a58
--- /dev/null
+++ b/node_modules/@endo/marshal/src/passStyleOf.d.ts
@@ -0,0 +1,19 @@
+export const passStyleOf: import("./types.js").PassStyleOf;
+export function assertPassable(val: any): void;
+export type PassStyleHelper = {
+    styleName: import("./types.js").PassStyle;
+    /**
+     * If `canBeValid` returns true, then the candidate would
+     * definitely not be valid for any of the other helpers.
+     * `assertValid` still needs to be called to determine if it
+     * actually is valid.
+     */
+    canBeValid: (candidate: any, check?: import("./types.js").Checker | undefined) => boolean;
+    assertValid: (candidate: any, passStyleOfRecur: import("./types.js").PassStyleOf) => void;
+};
+export type Passable = any;
+export type PassStyle = "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "null" | "copyRecord" | "copyArray" | "tagged" | "remotable" | "error" | "promise";
+export type PassStyleOf = (passable: any) => import("./types.js").PassStyle;
+export type PrimitiveStyle = "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "null";
+export type HelperPassStyle = "copyRecord" | "copyArray" | "tagged" | "remotable" | "error";
+//# sourceMappingURL=passStyleOf.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@endo/marshal/src/passStyleOf.d.ts.map b/node_modules/@endo/marshal/src/passStyleOf.d.ts.map
new file mode 100644
index 0000000..4df0946
--- /dev/null
+++ b/node_modules/@endo/marshal/src/passStyleOf.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"passStyleOf.d.ts","sourceRoot":"","sources":["passStyleOf.js"],"names":[],"mappings":"AAwMA,2DAMG;AAEI,+CAEN"}
\ No newline at end of file
diff --git a/node_modules/@endo/marshal/src/passStyleOf.js b/node_modules/@endo/marshal/src/passStyleOf.js
index 47e4d2a..ec5cbea 100644
--- a/node_modules/@endo/marshal/src/passStyleOf.js
+++ b/node_modules/@endo/marshal/src/passStyleOf.js
@@ -11,25 +11,27 @@ import { TaggedHelper } from './helpers/tagged.js';
 import { RemotableHelper } from './helpers/remotable.js';
 import { ErrorHelper } from './helpers/error.js';
 
-import './types.js';
-import './helpers/internal-types.js';
 import { assertPassableSymbol } from './helpers/symbol.js';
 
+/** @typedef {import('./helpers/internal-types.js').PassStyleHelper} PassStyleHelper */
+/** @typedef {import('./types.js').Passable} Passable */
+/** @typedef {import('./types.js').PassStyle} PassStyle */
+/** @typedef {import('./types.js').PassStyleOf} PassStyleOf */
+/** @typedef {import('./types.js').PrimitiveStyle} PrimitiveStyle */
+
+/** @typedef {Exclude<PassStyle, PrimitiveStyle | "promise">} HelperPassStyle */
+
 const { details: X, quote: q } = assert;
 const { ownKeys } = Reflect;
 const { isFrozen } = Object;
 
 /**
- * @param {PassStyleHelper[]} passStyleHelpers The passStyleHelpers to register,
- * in priority order.
- * NOTE These must all be "trusted",
- * complete, and non-colliding. `makePassStyleOf` may *assume* that each helper
- * does what it is supposed to do. `makePassStyleOf` is not trying to defend
- * itself against malicious helpers, though it does defend against some
- * accidents.
- * @returns {PassStyleOf}
+ * @param {PassStyleHelper[]} passStyleHelpers
+ * @returns {Record<HelperPassStyle, PassStyleHelper> }
  */
-const makePassStyleOf = passStyleHelpers => {
+
+const makeHelperTable = passStyleHelpers => {
+  /** @type {Record<HelperPassStyle, any> & {__proto__: null}} */
   const HelperTable = {
     __proto__: null,
     copyArray: undefined,
@@ -54,7 +56,22 @@ const makePassStyleOf = passStyleHelpers => {
       X`missing helper for ${q(styleName)}`,
     );
   }
-  harden(HelperTable);
+
+  return harden(HelperTable);
+};
+
+/**
+ * @param {PassStyleHelper[]} passStyleHelpers The passStyleHelpers to register,
+ * in priority order.
+ * NOTE These must all be "trusted",
+ * complete, and non-colliding. `makePassStyleOf` may *assume* that each helper
+ * does what it is supposed to do. `makePassStyleOf` is not trying to defend
+ * itself against malicious helpers, though it does defend against some
+ * accidents.
+ * @returns {PassStyleOf}
+ */
+const makePassStyleOf = passStyleHelpers => {
+  const HelperTable = makeHelperTable(passStyleHelpers);
   const remotableHelper = HelperTable.remotable;
 
   /**
diff --git a/node_modules/@endo/marshal/src/pureCopy.d.ts b/node_modules/@endo/marshal/src/pureCopy.d.ts
new file mode 100644
index 0000000..765f8f8
--- /dev/null
+++ b/node_modules/@endo/marshal/src/pureCopy.d.ts
@@ -0,0 +1,8 @@
+export function sameValueZero(x: any, y: any): boolean;
+export function pureCopy<T extends unknown>(val: T): T;
+export type OnlyData = any;
+export type CopyTagged = {
+    [Symbol.toStringTag]: string;
+    payload: any;
+};
+//# sourceMappingURL=pureCopy.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@endo/marshal/src/pureCopy.d.ts.map b/node_modules/@endo/marshal/src/pureCopy.d.ts.map
new file mode 100644
index 0000000..0a3f11c
--- /dev/null
+++ b/node_modules/@endo/marshal/src/pureCopy.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"pureCopy.d.ts","sourceRoot":"","sources":["pureCopy.js"],"names":[],"mappings":"AAyBO,iCAJI,GAAG,KACH,GAAG,GACD,OAAO,CAEsC;AAYnD,uDAiDN"}
\ No newline at end of file
diff --git a/node_modules/@endo/marshal/src/pureCopy.js b/node_modules/@endo/marshal/src/pureCopy.js
index 323d786..0579ef6 100644
--- a/node_modules/@endo/marshal/src/pureCopy.js
+++ b/node_modules/@endo/marshal/src/pureCopy.js
@@ -4,6 +4,9 @@ import { getTag } from './helpers/passStyle-helpers.js';
 import { makeTagged } from './makeTagged.js';
 import { passStyleOf } from './passStyleOf.js';
 
+/** @typedef {import('./types.js').OnlyData} OnlyData */
+/** @typedef {import('./types.js').CopyTagged} CopyTagged */
+
 const { is } = Object;
 const { details: X, quote: q } = assert;
 
diff --git a/node_modules/@endo/marshal/src/typeGuards.d.ts b/node_modules/@endo/marshal/src/typeGuards.d.ts
new file mode 100644
index 0000000..753e4f4
--- /dev/null
+++ b/node_modules/@endo/marshal/src/typeGuards.d.ts
@@ -0,0 +1,57 @@
+export type Passable = any;
+export type CopyArray<T> = T[];
+export type CopyRecord<T> = {
+    [x: string]: T;
+};
+export type Remotable = any;
+export type AssertArray = (array: Passable, optNameOfArray?: string | undefined) => asserts array is import("./types.js").CopyArray<any>;
+export type AssertRecord = (record: Passable, optNameOfRecord?: string | undefined) => asserts record is Record<string, any>;
+export type AssertRemotable = (remotable: Passable, optNameOfRemotable?: string | undefined) => asserts remotable is any;
+/**
+ * @callback AssertRecord
+ * @param {Passable} record
+ * @param {string=} optNameOfRecord
+ * @returns {asserts record is CopyRecord<any>}
+ */
+/** @type {AssertRecord} */
+export const assertRecord: AssertRecord;
+/**
+ * @callback AssertArray
+ * @param {Passable} array
+ * @param {string=} optNameOfArray
+ * @returns {asserts array is CopyArray<any>}
+ */
+/** @type {AssertArray} */
+export const assertCopyArray: AssertArray;
+/**
+ * @callback AssertRemotable
+ * @param {Passable} remotable
+ * @param {string=} optNameOfRemotable
+ * @returns {asserts remotable is Remotable}
+ */
+/** @type {AssertRemotable} */
+export const assertRemotable: AssertRemotable;
+/**
+ * Check whether the argument is a remotable.
+ *
+ * @param {Passable} remotable
+ * @returns {remotable is Remotable}
+ */
+export function isRemotable(remotable: Passable): remotable is any;
+/**
+ * Check whether the argument is a pass-by-copy record, AKA a
+ * "copyRecord" in @endo/marshal terms
+ *
+ * @param {Passable} record
+ * @returns {record is CopyRecord<any>}
+ */
+export function isRecord(record: Passable): record is Record<string, any>;
+/**
+ * Check whether the argument is a pass-by-copy array, AKA a "copyArray"
+ * in @endo/marshal terms
+ *
+ * @param {Passable} array
+ * @returns {array is CopyArray<any>}
+ */
+export function isCopyArray(array: Passable): array is import("./types.js").CopyArray<any>;
+//# sourceMappingURL=typeGuards.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@endo/marshal/src/typeGuards.d.ts.map b/node_modules/@endo/marshal/src/typeGuards.d.ts.map
new file mode 100644
index 0000000..b11c172
--- /dev/null
+++ b/node_modules/@endo/marshal/src/typeGuards.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"typeGuards.d.ts","sourceRoot":"","sources":["typeGuards.js"],"names":[],"mappings":";;;;;;kCA0CW,QAAQ,mBACR,MAAM;oCAkBN,QAAQ,oBACR,MAAM;0CAkBN,QAAQ,uBACR,MAAM;AAtBjB;;;;;GAKG;AAEH,2BAA2B;AAC3B,2BADW,YAAY,CASrB;AAnCF;;;;;GAKG;AAEH,0BAA0B;AAC1B,8BADW,WAAW,CASpB;AAsBF;;;;;GAKG;AAEH,8BAA8B;AAC9B,8BADW,eAAe,CAYxB;AAlEF;;;;;GAKG;AACH,uCAHW,QAAQ,oBAGoD;AAhBvE;;;;;;GAMG;AACH,iCAHW,QAAQ,iCAG4C;AAjB/D;;;;;;GAMG;AACH,mCAHW,QAAQ,gDAG4C"}
\ No newline at end of file
diff --git a/node_modules/@endo/marshal/src/typeGuards.js b/node_modules/@endo/marshal/src/typeGuards.js
index c789689..a41b079 100644
--- a/node_modules/@endo/marshal/src/typeGuards.js
+++ b/node_modules/@endo/marshal/src/typeGuards.js
@@ -2,6 +2,11 @@
 
 import { passStyleOf } from './passStyleOf.js';
 
+/** @typedef {import('./types.js').Passable} Passable */
+/** @template T @typedef {import('./types.js').CopyArray<T>} CopyArray */
+/** @template T @typedef {import('./types.js').CopyRecord<T>} CopyRecord */
+/** @typedef {import('./types.js').Remotable} Remotable */
+
 const { details: X, quote: q } = assert;
 
 /**
diff --git a/node_modules/@endo/marshal/src/types.d.ts b/node_modules/@endo/marshal/src/types.d.ts
new file mode 100644
index 0000000..bb7c567
--- /dev/null
+++ b/node_modules/@endo/marshal/src/types.d.ts
@@ -0,0 +1,244 @@
+export type PrimitiveStyle = "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "null";
+export type PassStyle = "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "null" | "copyRecord" | "copyArray" | "tagged" | "remotable" | "error" | "promise";
+/**
+ * A Passable value that may be marshalled. It is classified as one of
+ * PassStyle. A Passable must be hardened.
+ *
+ * A Passable has a pass-by-copy superstructure. This includes
+ *    * the atomic pass-by-copy primitives ("undefined" | "null" |
+ *      "boolean" | "number" | "bigint" | "string" | "symbol"),
+ *    * the pass-by-copy containers
+ *      ("copyRecord" | "copyArray" | "tagged") that
+ *      contain other Passables,
+ *    * and the special cases ("error" | "promise").
+ *
+ * A Passable's pass-by-copy superstructure ends in
+ * PassableCap leafs ("remotable" | "promise"). Since a
+ * Passable is hardened, its structure and classification is stable --- its
+ * structure and classification cannot change even if some of the objects are
+ * proxies.
+ */
+export type Passable = any;
+export type PassStyleOf = (passable: Passable) => PassStyle;
+/**
+ * A Passable is OnlyData when its pass-by-copy superstructure has no
+ * remotables, i.e., when all the leaves of the data structure tree are
+ * primitive data types or empty composites.
+ */
+export type OnlyData = any;
+/**
+ * An OnlyData value is PureData when it contains no hidden mutable state,
+ * e.g., when none of its pass-by-copy composite data objects are proxies. This
+ * cannot be determined by inspection. It can only be achieved by trusted
+ * construction. A PureData value cannot be used as a communications channel,
+ * and can therefore be safely shared with subgraphs that should not be able
+ * to communicate with each other.
+ */
+export type PureData = any;
+/**
+ * Might be an object explicitly declared to be `Remotable` using the
+ * `Far` or `Remotable` functions, or a remote presence of a Remotable.
+ */
+export type Remotable = any;
+/**
+ * The leaves of a Passable's pass-by-copy superstructure.
+ */
+export type PassableCap = any;
+export type CopyArray<T> = T[];
+export type CopyRecord<T> = {
+    [x: string]: T;
+};
+/**
+ * The tag is the value of the `[String.toStringTag]` property.
+ */
+export type CopyTagged = {
+    [Symbol.toStringTag]: string;
+    payload: Passable;
+};
+export type ConvertValToSlot<Slot> = (val: PassableCap) => Slot;
+export type ConvertSlotToVal<Slot> = (slot: Slot, iface?: InterfaceSpec | undefined) => PassableCap;
+export type EncodingClass<T> = {
+    '@qclass': T;
+};
+export type EncodingUnion = EncodingClass<"NaN"> | EncodingClass<"undefined"> | EncodingClass<"Infinity"> | EncodingClass<"-Infinity"> | (EncodingClass<"bigint"> & {
+    digits: string;
+}) | EncodingClass<"@@asyncIterator"> | (EncodingClass<"symbol"> & {
+    name: string;
+}) | (EncodingClass<"error"> & {
+    name: string;
+    message: string;
+    errorId?: string | undefined;
+}) | (EncodingClass<"slot"> & {
+    index: number;
+    iface?: string | undefined;
+}) | (EncodingClass<"hilbert"> & {
+    original: Encoding;
+    rest?: string | number | boolean | EncodingClass<"NaN"> | EncodingClass<"undefined"> | EncodingClass<"Infinity"> | EncodingClass<"-Infinity"> | (EncodingClass<"bigint"> & {
+        digits: string;
+    }) | EncodingClass<"@@asyncIterator"> | (EncodingClass<"symbol"> & {
+        name: string;
+    }) | (EncodingClass<"error"> & {
+        name: string;
+        message: string;
+        errorId?: string | undefined;
+    }) | (EncodingClass<"slot"> & {
+        index: number;
+        iface?: string | undefined;
+    }) | (EncodingClass<"hilbert"> & any) | (EncodingClass<"tagged"> & {
+        tag: string;
+        payload: Encoding;
+    }) | EncodingRecord | NestedArray<EncodingElement> | null | undefined;
+}) | (EncodingClass<"tagged"> & {
+    tag: string;
+    payload: Encoding;
+});
+/**
+ * We exclude '
+ */
+export type EncodingRecord = {
+    [index: string]: Encoding;
+    '@qclass'?: undefined;
+};
+export type EncodingElement = string | number | boolean | EncodingClass<"NaN"> | EncodingClass<"undefined"> | EncodingClass<"Infinity"> | EncodingClass<"-Infinity"> | (EncodingClass<"bigint"> & {
+    digits: string;
+}) | EncodingClass<"@@asyncIterator"> | (EncodingClass<"symbol"> & {
+    name: string;
+}) | (EncodingClass<"error"> & {
+    name: string;
+    message: string;
+    errorId?: string | undefined;
+}) | (EncodingClass<"slot"> & {
+    index: number;
+    iface?: string | undefined;
+}) | (EncodingClass<"hilbert"> & {
+    original: Encoding;
+    rest?: string | number | boolean | EncodingClass<"NaN"> | EncodingClass<"undefined"> | EncodingClass<"Infinity"> | EncodingClass<"-Infinity"> | (EncodingClass<"bigint"> & {
+        digits: string;
+    }) | EncodingClass<"@@asyncIterator"> | (EncodingClass<"symbol"> & {
+        name: string;
+    }) | (EncodingClass<"error"> & {
+        name: string;
+        message: string;
+        errorId?: string | undefined;
+    }) | (EncodingClass<"slot"> & {
+        index: number;
+        iface?: string | undefined;
+    }) | (EncodingClass<"hilbert"> & any) | (EncodingClass<"tagged"> & {
+        tag: string;
+        payload: Encoding;
+    }) | EncodingRecord | NestedArray<EncodingElement> | null | undefined;
+}) | (EncodingClass<"tagged"> & {
+    tag: string;
+    payload: Encoding;
+}) | EncodingRecord | null;
+/**
+ * The JSON structure that the data portion of a Passable serializes to.
+ *
+ * The QCLASS 'hilbert' is a reference to the Hilbert Hotel
+ * of https://www.ias.edu/ideas/2016/pires-hilbert-hotel
+ * If QCLASS appears as a property name in the data, we encode it instead
+ * as a QCLASS record of type 'hilbert'. To do so, we must move the other
+ * parts of the record into fields of the hilbert record.
+ */
+export type Encoding = string | number | boolean | EncodingClass<"NaN"> | EncodingClass<"undefined"> | EncodingClass<"Infinity"> | EncodingClass<"-Infinity"> | (EncodingClass<"bigint"> & {
+    digits: string;
+}) | EncodingClass<"@@asyncIterator"> | (EncodingClass<"symbol"> & {
+    name: string;
+}) | (EncodingClass<"error"> & {
+    name: string;
+    message: string;
+    errorId?: string | undefined;
+}) | (EncodingClass<"slot"> & {
+    index: number;
+    iface?: string | undefined;
+}) | (EncodingClass<"hilbert"> & {
+    original: Encoding;
+    rest?: string | number | boolean | EncodingClass<"NaN"> | EncodingClass<"undefined"> | EncodingClass<"Infinity"> | EncodingClass<"-Infinity"> | (EncodingClass<"bigint"> & {
+        digits: string;
+    }) | EncodingClass<"@@asyncIterator"> | (EncodingClass<"symbol"> & {
+        name: string;
+    }) | (EncodingClass<"error"> & {
+        name: string;
+        message: string;
+        errorId?: string | undefined;
+    }) | (EncodingClass<"slot"> & {
+        index: number;
+        iface?: string | undefined;
+    }) | (EncodingClass<"hilbert"> & any) | (EncodingClass<"tagged"> & {
+        tag: string;
+        payload: Encoding;
+    }) | EncodingRecord | NestedArray<EncodingElement> | null | undefined;
+}) | (EncodingClass<"tagged"> & {
+    tag: string;
+    payload: Encoding;
+}) | EncodingRecord | NestedArray<EncodingElement> | null;
+export type CapData<Slot> = {
+    /**
+     * A JSON.stringify of an Encoding
+     */
+    body: string;
+    slots: Slot[];
+};
+export type Serialize<Slot> = (val: Passable) => CapData<Slot>;
+export type Unserialize<Slot> = (data: CapData<Slot>) => Passable;
+export type Marshal<Slot> = {
+    serialize: Serialize<Slot>;
+    unserialize: Unserialize<Slot>;
+};
+export type MakeMarshalOptions = {
+    /**
+     * controls whether serialized errors
+     * also carry tagging information, made from `marshalName` and numbers
+     * generated (currently by counting) starting at `errorIdNum`. The
+     * `errorTagging` option defaults to `'on'`. Serialized
+     * errors are also logged to `marshalSaveError` only if tagging is `'on'`.
+     */
+    errorTagging?: ('on' | 'off') | undefined;
+    /**
+     * Used to identify sent errors.
+     */
+    marshalName?: string | undefined;
+    /**
+     * Ascending numbers staring from here
+     * identify the sending of errors relative to this marshal instance.
+     */
+    errorIdNum?: number | undefined;
+    /**
+     * If `errorTagging` is
+     * `'on'`, then errors serialized by this marshal instance are also
+     * logged by calling `marshalSaveError` *after* `assert.note` associated
+     * that error with its errorId. Thus, if `marshalSaveError` in turn logs
+     * to the normal console, which is the default, then the console will
+     * show that note showing the associated errorId.
+     */
+    marshalSaveError?: ((err: Error) => void) | undefined;
+};
+/**
+ * This is an interface specification.
+ * For now, it is just a string, but will eventually be any OnlyData. Either
+ * way, it must remain pure, so that it can be safely shared by subgraphs that
+ * are not supposed to be able to communicate.
+ */
+export type InterfaceSpec = string;
+/**
+ * Simple semantics, just tell what interface (or undefined) a remotable has.
+ */
+export type MarshalGetInterfaceOf = (maybeRemotable: any) => InterfaceSpec | undefined;
+/**
+ * Internal to a useful pattern for writing checking logic
+ * (a "checkFoo" function) that can be used to implement a predicate
+ * (an "isFoo" function) or a validator (an "assertFoo" function).
+ *
+ *  * A predicate ideally only returns `true` or `false` and rarely throws.
+ *  * A validator throws an informative diagnostic when the predicate
+ *    would have returned `false`, and simply returns `undefined` normally
+ *    when the predicate would have returned `true`.
+ *  * The internal checking function that they share is parameterized by a
+ *    `Checker` that determines how to proceed with a failure condition.
+ *    Predicates pass in an identity function as checker. Validators
+ *    pass in `assertChecker` which is a trivial wrapper around `assert`.
+ *
+ * See the various uses for good examples.
+ */
+export type Checker = (cond: boolean, details?: any | undefined) => boolean;
+//# sourceMappingURL=types.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@endo/marshal/src/types.d.ts.map b/node_modules/@endo/marshal/src/types.d.ts.map
new file mode 100644
index 0000000..d7f7980
--- /dev/null
+++ b/node_modules/@endo/marshal/src/types.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"types.d.ts","sourceRoot":"","sources":["types.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;qCA+CW,QAAQ,KACN,SAAS;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BAiEK,MAAM;aACnB,QAAQ;;2CAWX,WAAW;0DAQX,aAAa,iBACX,WAAW;;;;;YAayB,MAAM;;UAER,MAAM;;UACP,MAAM;aACH,MAAM;;;WAGT,MAAM;;;cACA,QAAQ;;gBARX,MAAM;;cAER,MAAM;;cACP,MAAM;iBACH,MAAM;;;eAGT,MAAM;;;aAIN,MAAM;iBACF,QAAQ;;;SADZ,MAAM;aACF,QAAQ;;;;;;;gBAI/B,SAAS;;;YAhBa,MAAM;;UAER,MAAM;;UACP,MAAM;aACH,MAAM;;;WAGT,MAAM;;;cACA,QAAQ;;gBARX,MAAM;;cAER,MAAM;;cACP,MAAM;iBACH,MAAM;;;eAGT,MAAM;;;aAIN,MAAM;iBACF,QAAQ;;;SADZ,MAAM;aACF,QAAQ;;;;;;;;;;;;YAZT,MAAM;;UAER,MAAM;;UACP,MAAM;aACH,MAAM;;;WAGT,MAAM;;;cACA,QAAQ;;gBARX,MAAM;;cAER,MAAM;;cACP,MAAM;iBACH,MAAM;;;eAGT,MAAM;;;aAIN,MAAM;iBACF,QAAQ;;;SADZ,MAAM;aACF,QAAQ;;;;;;UA0B5C,MAAM;;;oCAOT,QAAQ;yDAQN,QAAQ;;;;;;;;;;;;;oBAeP,IAAI,GAAC,KAAK;;;;kBAKV,MAAM;;;;;iBACN,MAAM;;;;;;;;;8BAEA,KAAK,KAAK,IAAI;;;;;;;;;;;;6DAsBrB,aAAa,GAAC,SAAS;;;;;;;;;;;;;;;;;6BAoBzB,OAAO,gCAEL,OAAO"}
\ No newline at end of file
diff --git a/node_modules/@endo/marshal/src/types.js b/node_modules/@endo/marshal/src/types.js
index 084887d..df1684d 100644
--- a/node_modules/@endo/marshal/src/types.js
+++ b/node_modules/@endo/marshal/src/types.js
@@ -3,6 +3,8 @@
 
 /// <reference path="extra-types.d.ts" />
 
+export {};
+
 /**
  * @typedef { "undefined" | "null" |
  *   "boolean" | "number" | "bigint" | "string" | "symbol"
@@ -180,7 +182,7 @@
 
 /**
  * @template Slot
- * @typedef CapData
+ * @typedef {Object} CapData
  * @property {string} body A JSON.stringify of an Encoding
  * @property {Slot[]} slots
  */
@@ -201,22 +203,16 @@
 
 /**
  * @template Slot
- * @typedef Marshal
+ * @typedef {Object} Marshal
  * @property {Serialize<Slot>} serialize
  * @property {Unserialize<Slot>} unserialize
  */
 
 /**
- * @template Slot
- * @callback MakeMarshal
- * @param {ConvertValToSlot<Slot>=} convertValToSlot
- * @param {ConvertSlotToVal<Slot>=} convertSlotToVal
- * @param {MakeMarshalOptions=} options
- * @returns {Marshal<Slot>}
  */
 
 /**
- * @typedef MakeMarshalOptions
+ * @typedef {Object} MakeMarshalOptions
  * @property {'on'|'off'=} errorTagging controls whether serialized errors
  * also carry tagging information, made from `marshalName` and numbers
  * generated (currently by counting) starting at `errorIdNum`. The
diff --git a/node_modules/@endo/marshal/tsconfig.json b/node_modules/@endo/marshal/tsconfig.json
new file mode 100644
index 0000000..1301850
--- /dev/null
+++ b/node_modules/@endo/marshal/tsconfig.json
@@ -0,0 +1,10 @@
+{
+  "extends": "./jsconfig.json",
+  "compilerOptions": {
+    "noEmit": false,
+    "declaration": true,
+    "emitDeclarationOnly": true,
+    "declarationMap": true
+  },
+  "exclude": ["test/"]
+}
